// +build ignore

// This program generates Go wrappers for opencl sources.
// The opencl file should contain exactly one __kernel void.

package main

import (
	"bufio"
	"bytes"
	"io"
	"os"
	"regexp"
	"text/template"

	"github.com/mumax/3cl/util"
)

// template data
type Kernel_headers struct {
        OCL  map[int]string
}

var ls_dir []string

func main() {
        // find .clh files
        if ls_dir == nil {
                dir, errd := os.Open(".")
                defer dir.Close()
                util.PanicErr(errd)
                var errls error
                ls_dir, errls = dir.Readdirnames(-1)
                util.PanicErr(errls)
        }

        idx := 0
	header_codes := &Kernel_headers{make(map[int]string)}
        for _, f := range ls_dir {
                match, e := regexp.MatchString("..clh$", f)
                util.PanicErr(e)
                if match {
                        header_codes.OCL[idx] = getHeaderFile(f)
                        idx++
                }
        }

        wrapfname := "clh_wrapper.go"
        wrapout, err := os.OpenFile(wrapfname, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
        util.PanicErr(err)
        defer wrapout.Close()
        util.PanicErr(templ.Execute(wrapout, header_codes))
}

func getHeaderFile(fname string) string {
        f, err := os.Open(fname)
        util.PanicErr(err)
        defer f.Close()
        in := bufio.NewReader(f)
        var out bytes.Buffer
        out.Write(([]byte)("`"))
        line, err := in.ReadBytes('\n')
        for err != io.EOF {
                util.PanicErr(err)
                out.Write(line)
                line, err = in.ReadBytes('\n')
        }
        out.Write(([]byte)("`"))
        return out.String()
}

// wrapper code template text
const templText = `package opencl

/*
 THIS FILE IS AUTO-GENERATED BY CLH2GO.
 EDITING IS FUTILE.
*/

var Kernel_headers map[int]string

func init() {
{{range $k, $v := .OCL}}
 Kernel_headers[{{$k}}] = {{$v}}

{{end}}
}

`

// wrapper code template
var templ = template.Must(template.New("wrap").Parse(templText))

