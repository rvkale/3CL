// +build ignore

// This program generates Go wrappers for opencl sources.
// The opencl file should contain exactly one __kernel void.

package main

import (
	"bufio"
	"bytes"
	"io"
	"os"
	"regexp"
	"text/scanner"
	"text/template"

	"github.com/mumax/3cl/util"
)

// template data
type Kernel_headers struct {
        OCL  map[string]string
}

type Kernel struct {
	Name	map[int]string
}

var ls_dir []string

func main() {
        // find .clh files
        if ls_dir == nil {
                dir, errd := os.Open(".")
                defer dir.Close()
                util.PanicErr(errd)
                var errls error
                ls_dir, errls = dir.Readdirnames(-1)
                util.PanicErr(errls)
        }

        // get header codes in .clh files
	header_codes := &Kernel_headers{make(map[string]string)}
        for _, f := range ls_dir {
                match, e := regexp.MatchString("..clh$", f)
                util.PanicErr(e)
                if match {
			fkey := f[:len(f)-len(".clh")]
                        header_codes.OCL[fkey] = getHeaderFile(f)
                }
        }

	// get names of kernels available in .cl files
	idx := 0
	kernel_codes := &Kernel{make(map[int]string)}
        for _, f := range ls_dir {
                match, e := regexp.MatchString("..cl$", f)
                util.PanicErr(e)
                if match {
                        kernel_codes.Name[idx] = getKernelName(f)
                        idx++
                }
        }

        wrapfname := "clh_wrapper.go"
        wrapout, err := os.OpenFile(wrapfname, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
        util.PanicErr(err)
        defer wrapout.Close()
        util.PanicErr(templ0.Execute(wrapout, header_codes))
        util.PanicErr(templ1.Execute(wrapout, kernel_codes))

}

func getKernelName(fname string) string {
        // open opencl file
        f, err := os.Open(fname)
        util.PanicErr(err)
        defer f.Close()

        // read tokens
        var token []string
        var s scanner.Scanner
        s.Init(f)
        tok := s.Scan()
        for tok != scanner.EOF {
                if !filter(s.TokenText()) {
                        token = append(token, s.TokenText())
                }
                tok = s.Scan()
        }

        // find function name and arguments
        funcname := ""
        argstart := -1
        for i := 0; i < len(token); i++ {
                if token[i] == "__kernel" {
                        funcname = token[i+2]
                        argstart = i + 4
                }
                if argstart > 0 && token[i] == ")" {
                        break
                }
        }
	return funcname	
}

func getHeaderFile(fname string) string {
        f, err := os.Open(fname)
        util.PanicErr(err)
        defer f.Close()
        in := bufio.NewReader(f)
        var out bytes.Buffer
        out.Write(([]byte)("`\n"))
        line, err := in.ReadBytes('\n')
        for err != io.EOF {
                util.PanicErr(err)
                out.Write(line)
                line, err = in.ReadBytes('\n')
        }
        out.Write(([]byte)("`"))
        return out.String()
}

// wrapper code template text
const templText0 = `package opencl

/*
 THIS FILE IS AUTO-GENERATED BY CLH2GO.
 EDITING IS FUTILE.
*/

func clhInit() {
{{range $k, $v := .OCL}}
  Kernel_headers["{{$k}}"] = {{$v}}

{{end}}

`

// wrapper code template text
const templText1 = `
{{range $k, $v := .Name}} k_{{$v}}_initialization()
{{end}}
}

`

// wrapper code template
var templ0 = template.Must(template.New("wrap").Parse(templText0))

var templ1 = template.Must(template.New("wrap0").Parse(templText1))

// should token be filtered out of stream?
func filter(token string) bool {
        switch token {
        case "__restrict":
                return true
        case "__global":
                return true
        case "__constant":
                return true
        case "__local":
                return true
        case "volatile":
                return true
        case "unsigned":
                return true
        case "signed":
                return true
        case "const":
                return true
        }
        return false
}


