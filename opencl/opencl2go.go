// +build ignore

// This program generates Go wrappers for opencl sources.
// The opencl file should contain exactly one __kernel void.

package main

import (
	"bufio"
	"bytes"
	"io"
	"os"
	"regexp"
	"text/scanner"
	"text/template"

	"github.com/mumax/3cl/util"
	"github.com/mumax/3cl/opencl/cl/kernels"
)

func main() {
        // find .clh files
        if ls_dirclh == nil {
                dirclh, errd := os.Open("./clh")
                defer dirclh.Close()
                util.PanicErr(errd)
                var errls error
                ls_dirclh, errls = dirclh.Readdirnames(-1)
                util.PanicErr(errls)
        }

        // find .cl files
        if ls_dircl == nil {
                dircl, errd := os.Open("./cl")
                defer dircl.Close()
                util.PanicErr(errd)
                var errls error
                ls_dircl, errls = dircl.Readdirnames(-1)
                util.PanicErr(errls)
        }

        // get header codes in .clh files
	header_codes := &Kernel_headers{make(map[string]string)}
        for _, f := range ls_dirclh {
                match, e := regexp.MatchString("..clh$", f)
                util.PanicErr(e)
                if match {
			fkey := f[:len(f)-len(".clh")]
                        header_codes.OCL[fkey] = getFile("./clh/"+f)
                }
        }

	// get names of kernels available in .cl files
	kernel_codes := &Kernel{make(map[string]string)}
        for _, f := range ls_dircl {
                match, e := regexp.MatchString("..cl$", f)
                util.PanicErr(e)
                if match {
			kname := getKernelName("./cl/"+f)
                        kernel_codes.Code[kname] = getFile("./cl/"+f)
                }
        }

        wrapfname := "clh_wrapper.go"
        wrapout, err := os.OpenFile(wrapfname, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
        util.PanicErr(err)
        defer wrapout.Close()
        util.PanicErr(templ0.Execute(wrapout, header_codes))
        util.PanicErr(templ1.Execute(wrapout, kernel_codes))

}

func getKernelName(fname string) string {
        // open opencl file
        f, err := os.Open(fname)
        util.PanicErr(err)
        defer f.Close()

        // read tokens
        var token []string
        var s scanner.Scanner
        s.Init(f)
        tok := s.Scan()
        for tok != scanner.EOF {
                if !filter(s.TokenText()) {
                        token = append(token, s.TokenText())
                }
                tok = s.Scan()
        }

        // find function name and arguments
        funcname := ""
        for i := 0; i < len(token); i++ {
                if token[i] == "__kernel" {
                        funcname = token[i+2]
			break
                }
        }
	return funcname
}

func getFile(fname string) string {
        f, err := os.Open(fname)
        util.PanicErr(err)
        defer f.Close()
        in := bufio.NewReader(f)
        var out bytes.Buffer
        out.Write(([]byte)("`\n"))
        line, err := in.ReadBytes('\n')
        for err != io.EOF {
                util.PanicErr(err)
                out.Write(line)
                line, err = in.ReadBytes('\n')
        }
        out.Write(([]byte)("`"))
        return out.String()
}

// wrapper code template text
const templText0 = `package kernels

/*
 THIS FILE IS AUTO-GENERATED BY CLH2GO.
 EDITING IS FUTILE.
*/

var Kernel_headers map[string]string
var Kernel_code map[string]string

func clhInit() {
{{range $k, $v := .OCL}}
  Kernel_headers["{{$k}}"] = {{$v}}

{{end}}

`

// wrapper code template text
const templText1 = `
{{range $k, $v := .Code}}
  Kernel_code["{{$k}}"] = {{$v}}

{{end}}
}

`

// wrapper code template
var templ0 = template.Must(template.New("wrap").Parse(templText0))

var templ1 = template.Must(template.New("wrap0").Parse(templText1))

// should token be filtered out of stream?
func filter(token string) bool {
        switch token {
        case "__restrict":
                return true
        case "__global":
                return true
        case "__constant":
                return true
        case "__local":
                return true
        case "volatile":
                return true
        case "unsigned":
                return true
        case "signed":
                return true
        case "const":
                return true
        }
        return false
}

